# 内存管理
不管什么编程语言，在代码的执行过程中都是需要给它分配内存的
不同的是某些编程语言需要我们自己手动的管理内存，(eg: C, C++)
某些编程语言会可以自动帮助我们管理内存 (eg: java, js
python, swift, dart)

## 内存生命周期
1. 分配申请你需要的内存（申请）；
2. 使用分配的内存 (存放)
3. 不需要使用时，对其进行销毁 (释放)

## js 的内存管理[[07.对象1]]
原始数据类型内存的分配会在执行时，直接在栈空间进行分配
于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用；

栈内存里的内容在堆内存内也会有一份, 如 VO: GO, 栈内存中的完成后即销毁, 而堆内存继续保留

##  GC 垃圾回收 (Garbage Collection)
内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。

## GC 算法
GC 怎么知道哪些对象是不再使用的-->GC算法
### 引用计数（Reference counting）
-  当一个对象有一个引用指向它时，那么这个对象的引用就+1； 
-  当一个对象的引用为 0 时，这个对象就可以被销毁掉；
弊端: 相互引用时会一直循环

### 标记清除（mark-Sweep）
核心思路是可达性（Reachability）

根对象: window, global object, root object 

设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象；
 这个算法可以很好的解决循环引用的问题；
![[Pasted image 20220611003452.png]]
### V8 优化 GC
#### 标记整理 (紧凑)（Mark-Compact）
和“标记－清除”相似； 
 不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化；

#### 分代收集（Generational collection）
对象被分成两组：“新的”和“旧的"
- 完成工作后无用的对象，需要很快被清理；放在 new
- 长期需要使用的对象, 被检查频率减少, 放在 old

#### 增量收集（Incremental collection）
-  如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。 
-  所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟；

#### 闲时收集（Idle-time collection）
 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。


## V8 引擎内存图
![[Pasted image 20220610113307.png]]

# 闭包 Closure
又称词法闭包（Lexical Closure）或函数闭包（function closures）
一个普通的函数 function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境 ( lexical environment，词法环境) 就是一个闭包；

广义: JavaScript 中的函数都是闭包；
狭义: JavaScript 中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；

## 内存泄漏
![[Pasted image 20220611011245.png]]
上图中假如 createAdder (8) 不再使用, 则应予以释放, 但是由于 GO 中引用了 adder fn, 使得整个第三排的内存都不能得到释放, 形成的内存浪费称内存泄漏
解决:     `adder (8)=null`

## AO 内不使用内容的优化
AO 对象不会被销毁时，是否里面的所有属性都不会被释放？
浏览器会对已经定义但没有使用的内容进行释放