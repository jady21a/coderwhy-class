# 原型 prototype

## 对象的原型
js 中每个对象都有一个特殊的内置属性 \[[ prototype]] 对象，这个特殊的对象可以指向另外一个对象。

### 对象获取原型
- obj.__ proto__（但是这个是早期浏览器自己添加的，存在一定的兼容性问题, 因为\[[ prototype]] 在对象中是隐式存在的, 所以需要通过这种方式访问）
- Object. getPrototypeOf

作用: 
查找属性时会先在自己的对象自身查找, 有则直接返回, 
没有则在原型对象中查找
![[Pasted image 20220612231949.png]]

## 函数的原型
所有的函数都有一个 prototype 的属性（注意：不是__proto__）此处的原型是显式的, 可以直接获取
	箭头函数无原型
![[Pasted image 20220612232135.png]]

### new 操作符
 1. 在内存中创建一个新的对象（空对象）； 
 2. 这个对象内部的 [prototype] 属性会被赋值为该构造函数的 prototype 属性；
 3. 构造函数内部的 this，会指向创建出来的新对象；
 4. 执行函数的内部代码（函数体代码）；
 5. 如果构造函数没有返回非空对象，则返回创建出来的新对象；
将 Person 的显式原型 prototype 赋值给 new 出来新对象的隐式原型\[[prototype]]
![[Pasted image 20220612233601.png]]
![[Pasted image 20220612234908.png]]
### constructor (构造函数)
constructor 是原型对象上的一个默认属性, 它指向当前的函数对象；
![[Pasted image 20220612235839.png]]

### 重写原型对象
如果我们需要在原型上添加过多的属性，通常会重写整个原型对象
如果不重写 constructor, 新对象的 constructor 属性, 会指向 Object 构造函数, 而不是 Foo 构造函数
![[Pasted image 20220613104749.png]]

## 继承--面向对象的特性 
面向对象有三大特性
- 封装: 将属性和方法封装到一个类中
- 继承: 减少重复代码的数量，也是多态前提（纯面向对象中）
- 多态: 不同的对象在执行时表现出不同的形态

继承可以帮助我们将重复的代码和逻辑抽取到父类中，子类只需要直接继承过来使用即可；

- 原型继承
![[Pasted image 20220613153659.png]]
![[Pasted image 20220613153725.png]]

## 原型链  [[draw08_继承.excalidraw]]
从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：

## 原型链继承实现案例
借用构造函数, 使参数继承
原型继承, 使函数方法继续
1. 自己所想
__proto__有兼容性问题, 可能在其他浏览器产生问题
![[Pasted image 20220613154051.png]]

2. 上课最终方案
借用构造函数, 使参数继承
![[Pasted image 20220613171929.png|475]]
js----inherit
![[Pasted image 20220613155250.png|475]]
![[Pasted image 20220613155224.png]]

## Object 是所以类的父类
原型链最顶层的原型对象就是 Object 的原型对象
![[Pasted image 20220613175111.png]]

## 判断对象拥有的属性
- hasOwnProperty（不是在原型上的属性）
- in/for in (判断某个属性是否在某个对象或者对象的原型上)
- instanceof (检测构造函数（Person、Student 类）的 pototype，是否出现在某个实例对象的原型链上)
- isPrototypeOf (检测某个对象，是否出现在某个实例对象的原型链上)
![[Pasted image 20220624125253.png]]