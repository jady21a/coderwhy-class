# 生命周期
生命周期函数是一些钩子函数（回调函数），在某个时间会被 Vue 源码内部进行回调；
通过对生命周期函数的回调，可以知道目前组件正在经历什么阶段 ;
就可以在该生命周期中编写属于自己的逻辑代码了；

组件生命历程
beforeCreate 
1. 创建组件实例
created
2. template 模板编译
beforeMount
3. 挂载到虚拟 DOM-->真实 DOM-->页面显示
mounted
4. 数据改变更新
beforeUpdate
5. 根据最新生成的 VNode 生成新的虚拟 DOM-->真实 DOM
updated
6. 卸载 (如: v-if (false) )
 beforeUnmount
7. 将挂载在虚拟 DOM 中的 VNode 从虚拟 DOM 中移除-->真实 DOM 移除  
unmounted
![[Pasted image 20220831165210.png]]

![[Pasted image 20220830180216.png]]
![[Pasted image 20220831221353.png]]
# $refs
以给元素或者组件绑定一个 ref 的 attribute 属性；可以获取到 DOM 而不是像原生那样操作 DOM
![[Pasted image 20220831223747.png]]
![[Pasted image 20220831223710.png]]
## $parent 和 $root
访问父元素和根元素 (App)

# 动态组件 component :is


# keep-alive
让原本会被销毁 (卸载) 的组件继续存活

## 属性
- include (arr) 只有名称匹配的组件会被缓存
- exclude (arr) 除了匹配都会缓存 ![[Pasted image 20220831172152.png]]
- max (num) 最多可以缓存多少组件实例, 超过 num 时, 最近没有被访问的组件实例会被卸载

## 缓存组件的生命周期
缓存组件再次加载时不会执行 created 或者 mounted 等生命周期函数
要监听他什么时候再次加载和卸载组件可以用 activated 和 deactivated 
![[Pasted image 20220831172415.png]]

# 代码分包
## webpack 默认打包
组件之间是通过模块化直接依赖的, 因此所有组件 (包括根组件) 会被打包在一起 (如 app. js)
其他依赖包 (如: vue, axios 等源码库) 会被一起打包在另一个文件

问题
如果 app. js 文件的内容过大，会造成首屏渲染速度变慢；因此需要对一些不需要立即使用的组件进行分包
![[Pasted image 20220831172933.png]]

## vue 分包 (异步组件)
defineAsyncComponent 函数
参数可以为
 类型一：工厂函数，该工厂函数需要返回一个 Promise 对象； ![[Pasted image 20220831173126.png]]
 类型二：接受一个对象类型，对异步函数进行配置； ![[Pasted image 20220831173204.png]]

# v-model 在组件
前面 5.02_语法我们可以在 input 中使用 v-model 来完成双向绑定
v-model= v-bind: value + @事件

## 组件上使用 v-model
v-model= : model-value=" " + @update: model-value=" "

### 绑定多个属性
默认情况下的 v-model 其实是绑定了 :modelValue 属性和 @update: modelValue 的事件
如果需要绑定更多，可以给 v-model 传入一个参数，那么这个参数的名称就是我们绑定属性的名称；
![[Pasted image 20220831214334.png]]

# Mixin
提取出各组件相同的部分形成一个新文件组件, mixin 后会与原组件的内容混合
![[Pasted image 20220831215234.png]]

 混合时发生冲突时优先使用原组件的内容

## 全局混入
app 注册
![[Pasted image 20220831215458.png]]