# 描述
## es5
- ECS执行上下文栈：Execution Context Stack，用于执行上下文的栈结构；
- EC执行上下文：Execution Context，代码在执行之前会先创建对应的执行上下文；
- VO变量对象：Variable Object，上下文关联的 VO 对象，用于记录函数和变量声明；
- GO全局对象：Global Object，全局执行上下文关联的 VO 对象；
- AO 激活对象：Activation Object，函数执行上下文关联的 VO 对象；
- SC 作用域链：scope chain，作用域链，用于关联指向上下文的变量查找；

## es6
### 词法环境（Lexical Environments）
一个词法环境经常用于关联一个函数声明、代码块语句、try-catch 语句，当它们的代码被执行时，词法环境被创建出来

词法环境由环境记录（Environment Record）和一个外部词法环境（oute; r Lexical Environment）组成

### 环境记录（Environment Record）
Object environment record 对象环境记录 OER
(记录 window, 包括 var 声明的变量)
declarative environment record 声明环境记录 DER
(记录 const 和 let 声明的变量)
![[Pasted image 20220625234316.png]]

# let/const
let 声明变量 , 赋值后可更改
const (constant) 常量, 被赋值后不可更改 (如果是引用类型不可修改其引用地址, 但可以修改其内容)

## let/const 注意
- 不能重复声明
- 有块级作用域限制
- 不会给 window 推荐属性, 而是存储于声明环境记录
- 没有作用域提升 (声明前不可访问, 但解析就已创建)
- 暂时性死区 (TDZ, temporal dead zone)

## var/let/const 的选择
var 不用
先全部当做常量用 const 声明, 若后期发现为变量再改为let
# 块级作用域{ }
var 没有块级作用域, 只有全局作用域和函数作用域
通过 let, const, function, class 声明的标识符有块级作用域的限制

函数有块级作用域, 但是在外部任然可以访问, 是因为浏览器引擎对函数作了特殊处理

应用实例

