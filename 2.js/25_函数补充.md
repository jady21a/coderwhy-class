# 函数
## 函数属性
- name (函数名)
- length (形参个数, 不包括剩余参数...args)

## arguments
arguments 是一个对应于传递给函数的参数的类数组 (array-like) 对象。
array-like 意味着它不是一个数组类型，而是一个对象类型：
但是它却拥有数组的一些特性, 比如说 length，比如可以通过 index 索引来访问；
但是它却没有数组的一些方法，比如 filter、map 等

![[Pasted image 20220612113353.png]]
## args 转 Array
1. es6 Array. from /[... arguments]
2. for 遍历 push
3.  sclice. call
![[Pasted image 20220612125844.png]]
## 箭头函数不绑定 arg 和 this
在箭头函数中使用 arguments 会去上层作用域查找
![[Pasted image 20220612130242.png]]

## 剩余参数 (rest parameter) ..args
将不定数量的参数放入到一个数组中, 剩余参数必须放到最后一个位置
剩余参数和 arguments 的区别
- 剩余参数只包含没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参；
- arguments 对象不是一个真正的数组，而 rest 参数是一个真正的数组
- arguments 是早期的 ECMAScript 中为了方便去获取所有的参数提供的一个数据结构，而 rest 参数是 ES6 中提供并且希望以此来替代 arguments 的；
![[Pasted image 20220612130940.png]]

# 面向函数编程的概念
## 纯函数
- 确定的输入，确定的输出
- 输入与函数执行上下文外的信息无关
- 函数执行不能产生副作用
副作用:
如修改了全局变量，修改参数或者改变外部的存储；
有副作用容易产生 bug
![[Pasted image 20220612132426.png]]
### sclice&splice 
sclice 不会改变原数组, 是一个纯函数
splice 会改变原数组, 不是纯函数
![[Pasted image 20220612132102.png]]
### 纯函数优势
写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改；
用的时候，可以确定自己输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出；
React 中就要求我们无论是函数还是 class 声明一个组件，这个组件都必须像纯函数一样，保护它们的 props 不被修改：

## 柯里化 (currying)
柯里化是一种函数的转换，将一个函数从可调用的 f (a, b, c) 转换为可调用的 f (a)(b)(c)。
把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回结果的新函数
柯里化不会调用函数。它只是对函数进行转换。
![[Pasted image 20220612133235.png]]
### 柯里化优势
- 函数的职责单一
- 函数参数可复用

### 封装柯里化函数
![[Pasted image 20220612141530.png]]
## 组合函数合（Compose）
如我们现在需要对某一个数据进行函数的调用，执行两个函数 fn1 和 fn2，这两个函数是依次执行的
如果每次我们都需要进行两个函数的调用，操作上就会显得重复；
此时将二者组合起来会稍显简化
![[Pasted image 20220612142024.png]]
### 封装组合化函数
![[Pasted image 20220612142856.png]]
## with 语句 (不推荐)
扩展一个语句的作用域链。
![[Pasted image 20220612122747.png]]
## eval 函数 (不推荐)
将传入的字符串当做 JavaScript 代码来运行
将最后一句执行语句的结果，作为返回值；
![[Pasted image 20220612122859.png]]
不推荐:
- 可读性差
- 字符串容易被篡改, 被攻击风险高
- 须经过 js 解释器, 不能被 turbofan 优化,(热点函数不能直接被转为机器码)
# 严格模式
js 新的特性被加入，旧的功能也没有改变，这么做有利于兼容旧代码；
但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中；
严格模式会以更加严格的方式对代码进行检测和执行

严格模式后:
-  通过抛出错误来消除一些原有的静默（silent）错误；
-  让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）； 
-  禁用了在 ECMAScript 未来版本中可能会定义的一些语法；

### 开启严格模式
- 在 js 文件
- 在函数
“class” 和 “module” ，会自动启用 use strict；

### 严格模式限制
- ◼ 1. 无法意外的创建全局变量 
- ◼ 2. 严格模式会使引起静默失败 (silently fail, 注: 不报错也没有任何效果) 的赋值操作抛出异常 
- ◼ 3. 严格模式下试图删除不可删除的属性 
- ◼ 4. 严格模式不允许函数参数有相同的名称 
- ◼ 5. 不允许 0 的八进制语法 
- ◼ 6. 在严格模式下，不允许使用 with 
- ◼ 7. 在严格模式下，eval 不再为上层引用变量 
- ◼ 8. 严格模式下，this 绑定不会默认转成对象