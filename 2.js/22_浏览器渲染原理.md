# 网页解析过程
![[Pasted image 20220608022113.png]]
# 浏览器内核
layout engine 也称排版引擎
![[Pasted image 20220608004335.png]]

## 内核组成 
浏览器内核由渲染引擎 (html+css) 和 js 引擎 (解析 js 代码) 两部分组成
以 webkit 内核为例：
-  WebCore：负责 HTML 解析、布局、渲染等等相关的工作； 
-  JavaScriptCore：解析、执行 JavaScript 代码；
	- blink 内核的 js 引擎为V8
![[Pasted image 20220608004608.png]]

# 渲染引擎
## 解析渲染 html +css 的过程
https://www.html5rocks.com/en/tutorials/internals/howbrowserswork
![[Pasted image 20220608010358.png]]
step:
1. 解析 HTML, 构建 DOM tree ( 默认情况下服务器会给浏览器返回 index. html 文件，解析 HTML 是所有步骤的开始 )  
2. 遇到 CSS 的 link 元素, 下载解析 css 的同时继续解析 HTML, css 解析出 CSSOM（CSS Object Model，CSS 对象模型）
3. 构建 render tree (有了 DOM Tree 和 CSSOM Tree 后，结合二者来构建 Render Tree) 显示有哪些节点及其样式, 但不包含节点的尺寸, 位置
4. 在渲染树（Render Tree）上运行布局（Layout）以计算每个节点的尺寸、位置等信息；
5. 将每个节点绘制（Paint）到屏幕上, 即将元素的可见部分进行绘制, 把布局阶段计算的每个 frame 转为屏幕上实际的像素点；如文本、颜色、边框、阴影、替换元素（比如 img）
N: 
- link 元素不会阻塞 DOM Tree 的构建过程，但是会阻塞 Render Tree 的构建过程 (因为 Render Tree 在构建时，需要对应的 CSSOM Tree)
- Render Tree 和 DOM Tree 并不是一一对应的关系 (如对于 display 为 none 的元素，不会出现在 render tree 中)
##  reflow 回流/重排
第一次确定节点的大小和位置，称之为布局（layout）,
之后对节点的大小、位置修改重新计算 (layout 改变) 称之为回流。
### 引起回流:
-  DOM 结构发生改变（添加新的节点或者移除节点）； 
-  改变布局（修改了 width、height、padding、font-size 等值） 
-  窗口 resize（修改了窗口的尺寸等） 
-  调用 getComputedStyle 方法获取尺寸、位置信息； 

- 回流一定会引起重绘，回流是一件很消耗性能的事情。所以在开发中要尽量避免发生回流
### 避免回流
1. 修改样式时尽量一次性修改
	如通过cssText 修改，通过添加 class 修改
2.  尽量避免频繁的操作 DOM
	可以在一个 DocumentFragment 或者父元素中将要操作的 DOM 操作完成，再一次性的操作；
3. 尽量避免通过 getComputedStyle 获取尺寸、位置等信息；
4. 对某些元素使用 position 的 absolute 或者 fixed
	并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响
## repaint 重绘
第一次渲染内容称之为绘制（paint）
之后重新渲染称之为重绘
### 引起重绘:
- 修改背景色、文字颜色、边框颜色、边框样式等；

## composite 合成
![[Pasted image 20220608015212.png]]
默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的；
但是有些特殊属性会创建一个新的图层 (CompositingLayer 合成层), 并且新的图层可以利用 GPU 来加速绘制；因为每个合成层都是单独渲染的, 所以渲染有一定优化.

分层确实可以提高性能，但它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。

### 可以创建合成层的特殊属性
-  3D transforms 
-  video、canvas、iframe 
-  opacity 动画转换时； 
-  position: fixed (relative 和 sbsolute 不会)
-  will-change：实验属性，提前告诉浏览器元素可能发生哪些变化； 
-  animation 或 transition 设置了 opacity、transform；

打开图层
![[Pasted image 20220608100857.png]]
## script 在 HTML 的解析
浏览器在解析 HTML 的过程中，遇到了 script 元素不能继续构建 DOM 树
它会停止继续构建，首先下载 JavaScript 代码，并且执行 JavaScript 的脚本
只有等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树；

这样做是因为 js 可以操作 DOM, 边执行 js 边构建 DOM 会造成回流重绘

弊端:
js 内容多时解析下载需要较多时间, 如果将 js 代码放在末尾会造成需要更多时间, 而如果放在 html 之前则会造成在 js 脚本下载、执行完成之前，用户在界面上什么都看不到

### script 的属性 defer&async
#### defer 延迟
使浏览器下载 js 脚本时不会阻碍 DOM tree 的构建
如果脚本提前下载好了, 它会等 DOM tree 构建完成, 在DOMContentLoaded 事件之前先执行 defer 中的代码；
![[Pasted image 20220608020835.png]]
N:
- defer 可以提高页面的性能，并且推荐放到 head 元素中；
- 多个带 defer 的脚本可以保持正确的顺序执行。
- defer 仅适用于外部脚本，对于 script 默认内容会被忽略。
#### async 异步
async 是让一个脚本完全独立
下载执行 js 时不会影响 dom tree 构建
async 脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本
async 不会能保证在 DOMContentLoaded 之前或者之后执行

- defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，并且对多个 script 文件有顺序要求的；
- async 通常用于独立的脚本，对其他脚本，甚至 DOM 没有依赖的；

# js 引擎
V8 引擎[[23_V8引擎]]