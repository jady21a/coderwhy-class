# 基础
## 程序中的 foo、bar、baz
它们通常被用来作为函数、变量、文件的名词；
但是它们本身并没有特别的用途和意义；  常被称之为 “伪 (元语法) 变量”（metasyntactic variable）

## 函数是什么
函数其实就是某段代码的封装，这段代码帮助我们完成某一个功能
函数可以在任何地方调用

函数并不是一种神奇的语法结构，而是一种特殊的值。属于对象
使用函数可以提高编写的效率以及代码的复用性；

## 函数的写法
### 声明函数 (定义函数)
先声明, 后调用
![[Pasted image 20220514214142.png]]

N: 函数定义完后里面的代码是不会执行的，函数必须调用才会执行；
### 函数表达式
将函数赋值给变量
![[Pasted image 20220514234415.png]]
函数表达式允许省略函数名。通过变量名便可调用函数

### 声明函数和函数表达式的区别
- 声明函数可以在声明前被调用, 函数表达式只能在定义后被调用

当 JavaScript 准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数；
而函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。
## 头等公民-->函数（first-class function；第一类函数）
通常我们对作为头等公民的编程方式，称之为函数式编程, 这个也是 JavaScript 的一大特点；
1. 函数可以被赋值给变量 (函数表达式写法)
2. 让函数在变量之间来回传递
3. 函数可以作为另外一个函数的参数
4. 函数作为另外一个函数的返回值
5. 将函数存储在另外一个数据结构中

## 函数名的命名:
- 命名规则和前面变量名的命名规则是相同的； 
- 函数要尽量做到见名知意（并且函数通常是一些行为（action），所以尽量使用动词）；

## 参数
参数可以增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据
- 在函数内部，把参数当做变量使用，进行需要的数据处理 
-  函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递

-  形参（参数 parameter）：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用 
-  实参（参数 argument）：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的
	 -  默认情况下，arguments 对象是所有（非箭头）函数中都可用的局部变量；
	 - 该对象中存放着所有的调用者传入的参数，从 0 位置开始，依次存放；
	-  arguments 变量的类型是一个 object 类型（ array-like ），不是一个数组，但是和数组的用法看起来很相似；
	-  如果调用者传入的参数多余函数接收的参数，可以通过 arguments 去获取所有的参数；

练习:
-  练习一：传入一个名字，对这个人 say Hello 
-  练习二：为某个朋友唱生日快乐歌
-  练习三：传入两个数字，计算两个数字的和，并且打印结果
## 返回值
使用 return 关键字来返回结果；
-  一旦在函数中执行 return 操作，那么当前函数会终止； 
-  如果函数中没有使用 return 语句，那么函数有默认的返回值：undefined； 
-  如果函数使用 return 语句，但是 return 后面没有任何值，那么函数的返回值也是：undefined；
练习
- [x] ◼ 练习一：实现一个加法计算器 
- [x] ◼ 练习二：定义一个函数，传入宽高，计算矩形区域的面积 
- [x] ◼ 练习三：定义一个函数，传入半径，计算圆形的面积 
- [ ] ◼ 练习四：定义一个函数，传入 n（n 为正整数），计算 1~n 数字的和 #re
- [ ] ◼ 练习五： 传入一个数字，可以根据数字转化成显示为亿、万文字显示的文本；


## 变量
作用域（Scope）表示一些标识符的作用有效范围（所以也有被翻译为有效范围的）；
函数的作用域表示在函数内部定义的变量，只有在函数内部可以被访问到；
- 局部变量（Local Variables）定义在函数内部的变量，只有在函数内部可以被访问到
- 外部变量（Outer Variables）定义在函数外部的变量
- 全局变量  (Global Variables)  在函数之外声明的变量（在 script 中声明的）, 均可访问

- N: 通过 var 声明的全局变量会在 window 对象上添加一个属性
- 访问变量的顺序: 优先访问自己函数中的变量，没有找到时，逐步向上查找。
![[Pasted image 20220514120943.png]]


## 函数调用函数
![[Pasted image 20220514232324.png]]
自调
![[Pasted image 20220514232357.png]]
函数调用自己必须有结束条件，否则会产生无限调用，造成报错；

## 递归（Recursion）
函数调用自己也叫递归
 将一个复杂的任务，转化成可以重复执行的相同任务；

###  案例:  $x^n$    #re
1. 自带函数实现
 ![[Pasted image 20220515034429.png]]
2. for 循环实现
 ![[Pasted image 20220515034327.png]]
3. 递归实现 
![[Pasted image 20220515034337.png]]

### fibonacci 数列 #re
    // 数列: 1 1 2 3 5 8 13 21 34 55  ... x
    // 位置: 1 2 3 4 5 6 7  8  9  10  ... n
1. 递归
![[Pasted image 20220515035634.png]]
2. for
![[Pasted image 20220515035652.png]]