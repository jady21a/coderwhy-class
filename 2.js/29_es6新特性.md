# 描述
## es5
- ECS执行上下文栈：Execution Context Stack，用于执行上下文的栈结构；
- EC执行上下文：Execution Context，代码在执行之前会先创建对应的执行上下文；
- VO变量对象：Variable Object，上下文关联的 VO 对象，用于记录函数和变量声明；
- GO全局对象：Global Object，全局执行上下文关联的 VO 对象；
- AO 激活对象：Activation Object，函数执行上下文关联的 VO 对象；
- SC 作用域链：scope chain，作用域链，用于关联指向上下文的变量查找；

## es6
### 词法环境（Lexical Environments）
一个词法环境经常用于关联一个函数声明、代码块语句、try-catch 语句，当它们的代码被执行时，词法环境被创建出来

词法环境由环境记录（Environment Record）和一个外部词法环境（oute; r Lexical Environment）组成

### 环境记录（Environment Record）
Object environment record 对象环境记录 OER
(记录 window, 包括 var 声明的变量)
declarative environment record 声明环境记录 DER
(记录 const 和 let 声明的变量)
![[Pasted image 20220625234316.png]]

# let/const
let 声明变量 , 赋值后可更改
const (constant) 常量, 被赋值后不可更改 (如果是引用类型不可修改其引用地址, 但可以修改其内容)
![[Pasted image 20220626123218.png]]
![[Pasted image 20220626124446.png]]
## let/const 注意
- 不能重复声明
- 有块级作用域限制
- 不会给 window 添加属性, 而是存储于声明环境记录
- 没有作用域提升 (声明前不可访问, 但解析就已创建)
- 暂时性死区 (TDZ, temporal dead zone)
![[Pasted image 20220626123956.png]]
## var/let/const 的选择
var 不用
先全部当做常量用 const 声明, 若后期发现为变量再改为let
# 块级作用域{ }
var 没有块级作用域, 只有全局作用域和函数作用域
通过 let, const, function, class 声明的标识符有块级作用域的限制

函数有块级作用域, 但是在外部任然可以访问, 是因为浏览器引擎对函数作了特殊处理
![[Pasted image 20220626125218.png]]
应用实例
![[Pasted image 20220626130950.png]]


# 模板字符串
使字符串嵌入变量或表达式更简单美观
![[Pasted image 20220711080745.png]]

## 函数参数的默认值
新增?? (不传参数以及参数为 null 和 undefined 时, 使用默认值)
![[Pasted image 20220711084149.png]]

注意:
 1. 有默认参数的形参, 是不会计算在 length 之内 (并且后面所有的参数都不会计算在 length 之内)
 2. 有默认参数的形参尽量写到后面
 3. 剩余参数也是放到后面 (默认参数放到剩余参数的前面)
![[Pasted image 20220711091159.png]]
默认参数解构
![[Pasted image 20220711093242.png]]
## 箭头函数补充

剩余参数和 arguments 的区别

![[Pasted image 20220711093925.png]]
# 展开语法
![[Pasted image 20220711174708.png]]
可迭代: 数组/string/arguments
不可迭代: 对象
![[Pasted image 20220711174727.png]]

# 浅拷贝
![[Pasted image 20220711182138.png]]
![[Pasted image 20220711182211.png]]

# 数值表示
![[Pasted image 20220713132452.png]]
# symbol    [[03.变量和数据类型]]

# set
es6 之前, 存储数据的结构主要是数组和对象
之后增加了 set , map

set 类似于数组, 但是元素不能重复 (重复时会自动去重) ![[Pasted image 20220713190559.png]]
set 的属性: size
set 的方法: add (value ), delete (value ), has ( value), clear ( ), forEach (callback, [, thisArg] ), for of
![[Pasted image 20220713190633.png]]
## WeakSet
WeakSet 和 set 的区别
1. WeakSet 中只能存放对象类型，不能存放基本数据类型；
2. WeakSet 对元素的引用是弱引用，即如果没有其他引用对某个对象进行强引用，那么 GC 可以对该对象进行回收；
![[Pasted image 20220713191500.png]]
WeakSet 的方法: add ( ), delete ( ), has ( )
注意：WeakSet 不能遍历
因为 WeakSet 只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。
应用
![[Pasted image 20220710154014.png]]

# map 映射
用于存储映射关系
对象存储映射关系的弊端: key (属性名) 只能为字符串 (es6 增加了 symbol (对象))
而 map 的 key 可以为对象
![[Pasted image 20220713193323.png]]
map 属性: size
map 方法: set (key, value),  get (key), has (key), delete (key), clear (),  forEach (callback, [, thisArg]), for of
![[Pasted image 20220713193345.png]]
## WeakMap
WeakMap 和 map 的区别
1. WeakMap 的 key 只能使用对象，不接受其他的类型作为 key
2. WeakMap 的 key 对对象想的引用是弱引用，如果没有其他引用引用这个对象，那么 GC 可以回收该对象 ![[Pasted image 20220713193947.png]]
方法: set (key, value),  get (key), has (key), delete (key)
注意: WeakMap 不能遍历
应用: ![[Pasted image 20220710155016.png]]
# proxy, reflect
vue 响应式原理

# promise
用于处理异步的解决方案

# es Module 模块化开发
工程化
其他模块化方案：CommonJS、AMD、CMD 等方案；


# 迭代
可迭代: 数组/string/arguments
不可迭代: 对象